<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux工具之sed</title>
      <link href="/2019/08/18/101.html"/>
      <url>/2019/08/18/101.html</url>
      
        <content type="html"><![CDATA[<h1 id="sed"><a class="markdownIt-Anchor" href="#sed"></a> sed</h1><h2 id="基本用法"><a class="markdownIt-Anchor" href="#基本用法"></a> 基本用法</h2><p>有数据文件<code>data.txt</code>内容如下：</p><blockquote><p>1, jack, male, 28, beijing<br>2, yuanyuan, female, 26, chongqing<br>3, xiao, female, 26, sichuan<br>4, straw, male, 25, shanghai<br>5, lili, female, 23, chongqing</p></blockquote><p>看三个简单的例子理解sed的原理</p><p>例1：</p><pre class="highlight"><code class="sh">CMD:  sed <span class="hljs-string">''</span> data.txtOUTPUT:  1, jack, male, 28, beijing  2, yuanyuan, female, 26, chongqing  3, xiao, female, 26, sichuan  4, straw, male, 25, shanghai  5, lili, female, 23, chongqing</code></pre><p>例2：</p><pre class="highlight"><code class="sh">CMD:  sed <span class="hljs-string">'2p'</span> data.txtOUTPUT:  1, jack, male, 28, beijing  2, yuanyuan, female, 26, chongqing  2, yuanyuan, female, 26, chongqing  3, xiao, female, 26, sichuan  4, straw, male, 25, shanghai  5, lili, female, 23, chongqing</code></pre><p>例3：</p><pre class="highlight"><code class="sh">CMD:  sed <span class="hljs-string">'2d'</span> data.txtOUTPUT:  1, jack, male, 28, beijing  3, xiao, female, 26, sichuan  4, straw, male, 25, shanghai  5, lili, female, 23, chongqing</code></pre><p>可以简单归纳一下sed的命令格式：<code>awk [options] 'RANGE CMD' file</code></p><h3 id="sed工作原理"><a class="markdownIt-Anchor" href="#sed工作原理"></a> sed工作原理</h3><ol><li>读取文件的一行内容到其内存区，我们称为模式空间</li><li>判断该行内容是否属于待处理的范围内，如果不是进入第4步，如果是则进入第3步</li><li>执行sed命令</li><li>输出模式空间（-n选项控制，默认输出）继续回到第一步</li></ol><p>例1：由于没有任何sed命令，所以按行依次读入到模式空间后依次输出，所以得到文件内容</p><p>例2：这里的RANGE是2，表示第二行；要对属于RANGE的行执行sed命令<code>p</code>，即打印到标准输入；加上原本就应该输出模式空间的内容，所以就输出了两行第二行内容</p><p>例3：这里的RANGE是2，表示第二行；要对属于RANGE的行执行sed命令<code>d</code>，即删除该行；这时候模式空间就因这个命令给删除了，所以这一行就没有输出</p><p>那么像<code>p</code>和<code>d</code> 这样的命令还有什么呢？</p><table><thead><tr><th>sed命令</th><th>功能</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>向当前模式空间追加内容</td><td>sed ‘4a 4.5, xianxian, female, 28, beijing’ data.txt</td><td>如果是多行，添加换行符即可</td></tr><tr><td>i</td><td>与a命令一致，不同的是在模式空间前插入</td><td>sed ‘4i 3.5, …’ data.txt</td><td></td></tr><tr><td>d</td><td>删除当前模式空间内容</td><td>sed ‘2d’ data.txt</td><td></td></tr><tr><td>D</td><td>删除当前模式空间内容，直到遇到换行符为止</td><td></td><td></td></tr><tr><td>c</td><td>替换模式模块的内容</td><td>sed ‘3c 3.5, xianxian, female, 28, beijing’ data.txt</td><td></td></tr><tr><td>p</td><td>打印当前模式空间内容</td><td>sed ‘2p’ data.txt</td><td></td></tr><tr><td>P</td><td>打印当前模式空间内容直到遇到换行符为止</td><td></td><td></td></tr><tr><td>s</td><td>文本替换</td><td>sed ‘3s#i#I#g’ data.txt</td><td>将第三行的所有i替换为I，后面的g是标志，表示全部，否则只会替换第一个i</td></tr></tbody></table><h3 id="增删改查"><a class="markdownIt-Anchor" href="#增删改查"></a> 增删改查</h3><h4 id="添加内容"><a class="markdownIt-Anchor" href="#添加内容"></a> 添加内容</h4><p>在模式空间内容后添加内容</p><pre class="highlight"><code class="sh">CMD:  sed <span class="hljs-string">'4a 4.5, xianxian, female, 28, beijing'</span> data.txtOUTPUT:  1, jack, male, 28, beijing  2, yuanyuan, female, 26, chongqing  3, xiao, female, 26, sichuan  4, straw, male, 25, shanghai  4.5, xianxian, female, 28, beijing  5, lili, female, 23, chongqing</code></pre><p>在模式空间内容前添加内容</p><pre class="highlight"><code class="sh">CMD:  sed <span class="hljs-string">'4i 3.5, xianxian, female, 28, beijing'</span> data.txtOUTPUT:  1, jack, male, 28, beijing  2, yuanyuan, female, 26, chongqing  3, xiao, female, 26, sichuan  3.5, xianxian, female, 28, beijing  4, straw, male, 25, shanghai  5, lili, female, 23, chongqing</code></pre><h4 id="修改内容"><a class="markdownIt-Anchor" href="#修改内容"></a> 修改内容</h4><p>修改整个模式空间</p><pre class="highlight"><code class="sh">CMD:  sed <span class="hljs-string">'3c 3.5, xianxian, female, 28, beijing'</span> data.txtCMD:  1, jack, male, 28, beijing  2, yuanyuan, female, 26, chongqing  3.5, xianxian, female, 28, beijing  4, straw, male, 25, shanghai  5, lili, female, 23, chongqing</code></pre><h4 id="替换内容"><a class="markdownIt-Anchor" href="#替换内容"></a> 替换内容</h4><p>将模式空间中的所有小写i转成大写I，这里的#号可以换成任意的其他字符</p><pre class="highlight"><code class="sh">CMD:  sed <span class="hljs-string">'3s#i#I#g'</span> data.txtOUTPUT:  1, jack, male, 28, beijing  2, yuanyuan, female, 26, chongqing  3, xIao, female, 26, sIchuan  4, straw, male, 25, shanghai  5, lili, female, 23, chongqing</code></pre><p>替换的源头除了用字符串外，还可以是正则表达式（添加-r选项，表示使用扩展正则表达式，比如扩展正则表达式中括号不用反斜杠转义）；注意这里的<code>&amp;</code>符号表示匹配到的原始内容</p><pre class="highlight"><code class="sh">CMD:  sed -r <span class="hljs-string">'3s#[0-9]+#(&amp;)#g'</span> data.txtOUTPUT:  1, jack, male, 28, beijing  2, yuanyuan, female, 26, chongqing  (3), xiao, female, (26), sichuan  4, straw, male, 25, shanghai  5, lili, female, 23, chongqing</code></pre><p>加入想匹配模式空间中的所有内容，即整行</p><pre class="highlight"><code class>CMD:  sed -r '3s#.*#(&amp;)#g' data.txtOUTPUT:  1, jack, male, 28, beijing  2, yuanyuan, female, 26, chongqing  (3, xiao, female, 26, sichuan)  4, straw, male, 25, shanghai  5, lili, female, 23, chongqing</code></pre><p>也可以通过sed提取内容；通过这个命令我们可以发现，通过<code>\num</code>来使用正则表达式中引用</p><pre class="highlight"><code class>CMD:  sed -r '3s#([0-9]+), (.*), (.*), ([0-9]+), (.*)#name: \2, age: \4#g' data.txtOUTPUT:  1, jack, male, 28, beijing  2, yuanyuan, female, 26, chongqing  name: xiao, age: 26  4, straw, male, 25, shanghai  5, lili, female, 23, chongqing</code></pre><p>假如想要在行首或者行尾添加东西</p><pre class="highlight"><code class>CMD:  sed '3s|^|# |g' data.txtOUTPUT:  1, jack, male, 28, beijing  2, yuanyuan, female, 26, chongqing  # 3, xiao, female, 26, sichuan  4, straw, male, 25, shanghai  5, lili, female, 23, chongqing</code></pre><p>行尾使用<code>$</code></p><h3 id="关于range"><a class="markdownIt-Anchor" href="#关于range"></a> 关于RANGE</h3><p>前面的示例我们都只是演示了一种形式的RANGE，即行号；其实还有很多种其他的，见如下表</p><table><thead><tr><th>RANGE</th><th>功能</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>不指定</td><td>sed ‘d’ data.txt</td><td>sed命令将作用于行，将删除每一行</td><td></td></tr><tr><td>2,4</td><td>指定2-4行</td><td>sed ‘2,4d’ data.txt</td><td>将对2、3、4行执行删除动作</td></tr><tr><td>2,+4</td><td>指定2到2+4行</td><td>sed ‘2,+4d’ data.txt</td><td>将对2、3、4、5、6行执行删除动作</td></tr><tr><td>2,$</td><td>指定2到最后一行</td><td>sed ‘2,$d’ data.txt</td><td>将对2到最后一行执行删除动作</td></tr><tr><td>1~2</td><td>从第一行开始递增2的行</td><td>sed ‘1~2d’ data.txt</td><td>对1、3、5行执行删除动作</td></tr><tr><td>/KEYWORD/</td><td>匹配到KEYWORD的行</td><td>sed ‘/xiao/d’ data.txt</td><td>删除匹配到单词xiao的这行</td></tr><tr><td>/KEYWORD1/,/KEYWORD2/</td><td>从匹配到KEYWORD1到KEYWORD2的行</td><td>sed ‘/xiao/,/lili/d’ data.txt</td><td>将对第3到5行执行删除动作</td></tr><tr><td>/KEYWORD/,3</td><td>匹配KEYWORD到第3行</td><td></td><td>如果前面3行没匹配到KEYWORD，就没有匹配的行</td></tr><tr><td>3,/KEYWORD/</td><td>匹配第3行到匹配到KEYWORD的行</td><td></td><td>如果第3行后没有匹配到KEYWORD，将默认匹配到最后一行</td></tr><tr><td>!</td><td>前面的返回取反</td><td>sed ‘2,4!d’ data.txt</td><td>除了2、3、4行外，执行删除</td></tr></tbody></table><h3 id="常用选项"><a class="markdownIt-Anchor" href="#常用选项"></a> 常用选项</h3><p>前面我们在工作原理那一节说过，sed会将处理过后的模式空间内容自动输出，有时间我们不需要这个功能，我们就可以使用<code>-n</code>禁止默认的模式空间输出，同样的还有其他的，见一下表：</p><table><thead><tr><th>sed选项</th><th>功能</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><code>-n</code></td><td>禁止默认的模式空间打印</td><td><code>sed -n '3p' data.txt</code></td><td></td></tr><tr><td><code>-r</code></td><td>使用扩展的正则表达式</td><td><code>sed -r '3s#([0-9]+), (.*), (.*), ([0-9]+), (.*)#name: \2, age: \4#g' data.txt</code></td><td>如果不用该选项，这里的括号必须要转义</td></tr><tr><td><code>-e</code></td><td>可以接多个sed命令</td><td><code>sed -n -e '3d' -e '1p' data.txt</code></td><td>删除第三行，打印第一行；同<code>sed -n '3d;1p' data.txt</code></td></tr><tr><td><code>-i</code></td><td>使用模式空间的内容替换原内容</td><td><code>sed -i '3p' data.txt</code></td><td>data.txt文件的第三行将复制一行</td></tr></tbody></table><ol><li><code>-n</code>选项<br>禁止默认的模式空间内容打印<pre class="highlight"><code class>CMD:  sed -n '3p' data.txtOUTPUT:  3, xiao, female, 26, sichuan</code></pre>默认的输出禁止掉了，就只会打印这里指定打印的第三行</li><li><code>-e</code>选项<br>执行多个sed命令<pre class="highlight"><code class>CMD:  sed -n -e '3d' -e '1p' data.txt    # 同：sed -n '3d;1p' data.txtOUTPUT:  1, jack, male, 28, beijing</code></pre></li></ol><h2 id="进阶用法"><a class="markdownIt-Anchor" href="#进阶用法"></a> 进阶用法</h2><h2 id="高级用法"><a class="markdownIt-Anchor" href="#高级用法"></a> 高级用法</h2><ol><li><p>高级sed命令<code>n</code>，提前读取下一行，覆盖当前模式空间<br>覆盖前如果有默认输出，会先输出覆盖前的模式空间内容</p><pre class="highlight"><code class>CMD:  sed 'n;p' data.txtOUTPUT:  1, jack, male, 28, beijing  2, yuanyuan, female, 26, chongqing  2, yuanyuan, female, 26, chongqing  3, xiao, female, 26, sichuan  4, straw, male, 25, shanghai  4, straw, male, 25, shanghai  5, lili, female, 23, chongqing解释:  读取第一行后，执行第一个命令n读入下一行，读入前会先输出模式空间内容，所以第一行打印了；执行n命令这时候读入的是第二行命令，执行p命令后，继续输出模式空间内容，所以第2行打印了两次；再读入下一行就是从第3行开始，因为第二行已经通过n命令读入了如果取消默认输出CMD:  sed -n 'n;p' data.txtOUTPUT:  2, yuanyuan, female, 26, chongqing  4, straw, male, 25, shanghai解释：  取消了默认的模式空间输出，就只是会输出p命令的打印内容，所以会输出偶数行CMD:  sed 'n;d' data.txtOUTPUT:  1, jack, male, 28, beijing  3, xiao, female, 26, sichuan  5, lili, female, 23, chongqing解释：  读取第一行后，执行sed命令n读入下一行，读入前先输出了模式空间内容，所以第一行打印了；n命令会读入第二行内容到模式空间，执行d命令后，模式空间内容清空了，所以没有输出的；继续读取第三行内容依次类推；通过这种方式输出基数行CMD:  sed -n '$!N;P' data.txtOUTPUT:  1, jack, male, 28, beijing  3, xiao, female, 26, sichuan  5, lili, female, 23, chongqing解释：  这里的P也是打印模式空间内容，只是它打印直到遇到换行符为止；前面的$!表示判断是否为最后一行，如果没有就会将最后一行忽略</code></pre></li><li><p>高级sed命令<code>N</code>，提前读取下一行，追加到当前模式空间<br>假设有如下数据</p><pre class="highlight"><code class>user1pass1user2pass2user3pass3user4pass4</code></pre><p>一个用户一个密码，依次按行放置，现在想将一个用户及其密码放到一行来</p><pre class="highlight"><code class>CMD:  sed 'N;s#\n#=#g' new.txt  sed -n 'N;s#\n#=#g;p' new.txtOUTPUT:  user1=pass1  user2=pass2  user3=pass3  user4=pass4解释：  跟n一样也是提前读取下一行，但是会追加到当前模式空间，所以两行中间是有换行符的；再使用s命令将换行符换成=号</code></pre></li></ol><h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux工具之grep</title>
      <link href="/2019/08/18/102.html"/>
      <url>/2019/08/18/102.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux工具之awk</title>
      <link href="/2019/08/18/100.html"/>
      <url>/2019/08/18/100.html</url>
      
        <content type="html"><![CDATA[<h1 id="awk"><a class="markdownIt-Anchor" href="#awk"></a> awk</h1><p>awk不仅仅是linux系统上的一个命令，它更是一种编程语言，可以用来处理数据和生成报告</p><p>awk处理的数据来源可以是文件，也可以是标准输入；其可以在命令行上直接编辑命令进行操作，同时还可以写成程序去处理复杂的任务</p><h2 id="基本用法"><a class="markdownIt-Anchor" href="#基本用法"></a> 基本用法</h2><p>有数据文件内容如下：</p><blockquote><p>jack, male, 28, beijing<br>yuanyuan, female, 26, chongqing<br>xiao, female, 26, sichuan<br>straw, male, 25, shanghai<br>lili, female, 23, chongqing</p></blockquote><p>例子：</p><pre class="highlight"><code class>CMD:  cat data.txt |awk -F&quot;[, ]+&quot; '$2 ~ /female/ {print NR,$3,$NF}'OUTPUT:  2 26 chongqing  3 26 sichuan  5 23 chongqing</code></pre><p>awk命令构成</p><pre class="highlight"><code class>awk [options] 'pattern {action}' file</code></pre><p>其中<code>-F&quot;[, ]+&quot;</code>是选项，<code>$2 ~ /female/</code>是模式，<code>{print NR,$3,$NF}</code>是动作；</p><h3 id="域和记录"><a class="markdownIt-Anchor" href="#域和记录"></a> 域和记录</h3><h4 id="域"><a class="markdownIt-Anchor" href="#域"></a> 域</h4><p>awk中默认将一个记录按空格作为分隔符来分割为多个域，可以使用选项<code>-F</code>指定自定义域分隔符</p><p>分割为多个域后通过<code>$</code>来访问，如果将一个记录分割后的域当做数组的话，那这个数组是从1开始计数的；<code>$1</code>表示第一个域，<code>$2</code>表示第二个域，…，<code>$NF</code>表示最后一个域；如果要访问整行记录使用<code>$0</code></p><p>相关变量</p><table><thead><tr><th>变量</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>NF</td><td>number of field，域总数</td><td>可以通过<code>$NR</code>访问最后一个域</td></tr><tr><td>FS</td><td>输入域分隔符</td><td>可以通过<code>BEGIN{FS=&quot;[, ]+&quot;}</code>达到与<code>-F</code>参数同样的效果，如：<code>cat data.txt |awk 'BEGIN{FS=&quot;[, ]+&quot;} $2 ~ /^f/ {print $1,$3}'</code></td></tr><tr><td>OFS</td><td>输出域分隔符</td><td>与FS类似，也是在BEGIN阶段设置</td></tr></tbody></table><h4 id="记录"><a class="markdownIt-Anchor" href="#记录"></a> 记录</h4><p>awk中默认将每一行作为一个记录，意思是awk会按换行符将文件的内容分为多个记录，拿上面的例子，每个人的所有信息为一个记录。在模式与动作中可以使用变量<code>NR</code>，这个变量表示当前处理的记录号，默认记录分隔符的话就应该是行号</p><p>相关变量</p><table><thead><tr><th>变量</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>NR</td><td>number of record，当前记录的计数</td><td>默认是行号</td></tr><tr><td>RS</td><td>记录的分隔符</td><td>默认是换行符</td></tr><tr><td>ORS</td><td>输出域分隔符</td><td>默认是换行符</td></tr></tbody></table><h3 id="action"><a class="markdownIt-Anchor" href="#action"></a> action</h3><p>上面例子中的<code>print</code>是动作，表示要打印到标准输出，这是比较常见的动作，经常会使用。</p><p>这里的动作将应用于当前的记录</p><h3 id="pattern"><a class="markdownIt-Anchor" href="#pattern"></a> pattern</h3><p>这里使用<code>~</code>来进行正则匹配，表示第2列满足后面的正则表达式的记录才执行后面的动作，支持的匹配方法：</p><table><thead><tr><th>符号</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td><code>~</code></td><td><code>$2 ~ /female/</code></td><td>匹配<code>//</code>中的正则表达式的记录才会执行动作</td></tr><tr><td><code>!~</code></td><td><code>$2 ~ /male/</code></td><td>不匹配<code>//</code>中的正则表达式的记录才会执行动作</td></tr><tr><td><code>&gt;</code></td><td><code>$3 &gt; 25</code></td><td>年龄大于25的动作才执行动作</td></tr><tr><td><code>&lt;</code></td><td><code>$3 &lt; 26</code></td><td>年龄小于26的动作才执行动作</td></tr><tr><td><code>==</code></td><td><code>$3 == 28</code></td><td>年龄为28的记录才执行动作</td></tr><tr><td><code>&amp;&amp;</code></td><td><code>$3 &gt; 23 &amp;&amp; $3 &lt; 28</code></td><td>多条件同时成立</td></tr><tr><td><code>||</code></td><td><code>$3 &lt; 25 || $3 &gt; 26</code></td><td>多条件求并集</td></tr></tbody></table><p>关于正则表达式常见符号</p><table><thead><tr><th>符号</th><th>解释</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><code>^</code></td><td>匹配开头</td><td>如：<code>$2 ~ /^f/</code></td><td></td></tr><tr><td><code>$</code></td><td>匹配结尾</td><td>如：<code>$1 ~ /w$/</code></td><td></td></tr><tr><td><code>{m,n}</code></td><td>匹配数量</td><td><code>$1 ~ /^[a-z]{4,5}$/</code></td><td>某些awk版本可能需要参数<code>--posix</code></td></tr></tbody></table><h3 id="options"><a class="markdownIt-Anchor" href="#options"></a> options</h3><table><thead><tr><th>参数</th><th>解释</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>-F</td><td>指定域分隔符</td><td><code>-F&quot;[, ]+&quot;、-F:</code></td><td>默认为空格</td></tr><tr><td>–posix</td><td>使用posix标准正则表达式</td><td></td><td></td></tr></tbody></table><h3 id="awk工作方式"><a class="markdownIt-Anchor" href="#awk工作方式"></a> awk工作方式</h3><ol><li>按行分割符读取一个记录到缓存区</li><li>按域分隔符将该记录分割为一个一个域</li><li>如果存在pattern部分，进入第4步；如果不存在pattern部分，直接进入第5步</li><li>如果满足pattern的条件，进入第5步；如果不满足pattern的条件回到第1步</li><li>执行动作</li></ol><h2 id="进阶用法"><a class="markdownIt-Anchor" href="#进阶用法"></a> 进阶用法</h2><h3 id="begin与end模块"><a class="markdownIt-Anchor" href="#begin与end模块"></a> BEGIN与END模块</h3><h4 id="begin模块"><a class="markdownIt-Anchor" href="#begin模块"></a> BEGIN模块</h4><p>awk读取文件前就执行BEGIN模块的代码，一般用来定义内置变量的值，比如设置记录分隔符RS、ORS、域分隔符FS、ORS、自定义变量等</p><pre class="highlight"><code class>CMD:  cat data.txt |awk 'BEGIN{FS=&quot;[, ]+&quot;;OFS=&quot;:&quot;} {print $1,$3}'OUTPUT:  jack:28  yuanyuan:26  xiao:26  straw:25  lili:23# 如果有BEGIN阶段还有pattern条件CMD:  cat data.txt |awk 'BEGIN{FS=&quot;[, ]+&quot;;OFS=&quot;:&quot;} $3 &gt; 26 {print $1,$3}'OUTPUT:  jack:28</code></pre><h4 id="end模块"><a class="markdownIt-Anchor" href="#end模块"></a> END模块</h4><p>当所有记录都处理完了后就会执行END模块的代码，一般用来输出一个结果，比如累加、数组等</p><pre class="highlight"><code class>CMD:  cat data.txt |awk -F&quot;[, ]+&quot; 'BEGIN{sum=0} {sum+=$3} END{print sum/NR}'OUTPUT:  25.6</code></pre><h3 id="awk数组"><a class="markdownIt-Anchor" href="#awk数组"></a> awk数组</h3><pre class="highlight"><code class="shell">CMD:  echo |awk 'BEGIN{arr["a"]="aa";arr["b"]="bb";arr["c"]="cc"}END{for (key in arr) {print(arr[key])}}'OUTPUT:  aa  bb  cc</code></pre><p>awk中的任何变量都不需要申明，直接使用即可</p><h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2><h3 id="一个自动登录程序"><a class="markdownIt-Anchor" href="#一个自动登录程序"></a> 一个自动登录程序</h3><p>数据如下：</p><blockquote><p>1   machine1    username1    host1    password1<br>2   machine2    username2    host2    password2<br>3   machine3    username3    host3    password3</p></blockquote><pre class="highlight"><code class="sh"><span class="hljs-meta">#!/bin/sh</span>PASSFILE=<span class="hljs-string">"./passwd.data"</span>key=<span class="hljs-variable">$1</span>cat <span class="hljs-variable">$PASSFILE</span>| awk -F<span class="hljs-string">"[\t ]+"</span> <span class="hljs-string">'$0 ~ /'</span><span class="hljs-string">"<span class="hljs-variable">$key</span>"</span><span class="hljs-string">'/ {print $1,$2,$3,$4}'</span><span class="hljs-built_in">printf</span> <span class="hljs-string">"please choose one: "</span><span class="hljs-built_in">read</span> choose<span class="hljs-keyword">if</span> [[ <span class="hljs-string">"<span class="hljs-variable">$choose</span>"</span> != <span class="hljs-string">""</span> &amp;&amp; <span class="hljs-variable">$choose</span> -ge 0 ]]<span class="hljs-keyword">then</span>    <span class="hljs-built_in">eval</span> $(cat <span class="hljs-variable">$PASSFILE</span>| awk -F<span class="hljs-string">"[\t ]+"</span> <span class="hljs-string">'$1 == '</span><span class="hljs-string">"<span class="hljs-variable">$choose</span>"</span><span class="hljs-string">' {printf("arr=([1]=%s [2]=%s [3]=%s)",$3,$4,$5)}'</span>)    user=<span class="hljs-variable">${arr[1]}</span>    host=<span class="hljs-variable">${arr[2]}</span>    pass=<span class="hljs-variable">${arr[3]}</span>    <span class="hljs-comment"># 结合expect实现自动登录</span>    <span class="hljs-built_in">echo</span> <span class="hljs-string">"ssh <span class="hljs-variable">${user}</span>@<span class="hljs-variable">${host}</span> &lt; <span class="hljs-variable">${pass}</span>"</span><span class="hljs-keyword">fi</span></code></pre><h3 id="统计文件单词出现次数"><a class="markdownIt-Anchor" href="#统计文件单词出现次数"></a> 统计文件单词出现次数</h3><pre class="highlight"><code class="sh">sed -r <span class="hljs-string">'s#[^a-zA-Z]+# #g'</span> data.txt |awk <span class="hljs-string">'BEGIN{RS="[ \t\n]+"} {print $0}'</span> |sort |uniq -c |sort -n</code></pre><h3 id="统计与本机建立连接的ip机器连接数"><a class="markdownIt-Anchor" href="#统计与本机建立连接的ip机器连接数"></a> 统计与本机建立连接的ip机器连接数</h3><pre class="highlight"><code class="sh">netstat -an |grep ESTABLISHED |awk <span class="hljs-string">'{print $5}'</span> |awk -F: <span class="hljs-string">'{print $1}'</span> |sort |uniq -c |sort -nr</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
